# Архитектура приложения для тестирования

Этот документ описывает архитектуру приложения для проведения тестов, построенного на PyQt5. Основной принцип — разделение ответственностей (Separation of Concerns), близкий к паттерну MVC (Model-View-Controller).

## 1. Структура Проекта

```
/test_project
|
├── data/                  # Директория для хранения данных тестов (например, в JSON)
|   ├── biology_test.json
|   └── math_test.json
|
├── domain/                # Модели данных (основные сущности)
|   ├── question.py        # Классы Question и Answer
|   └── quiz.py            # Класс Quiz (представляет собой один тест)
|
├── services/              # Служебные классы (бизнес-логика)
|   ├── quiz_loader.py     # Загрузчик тестов из файлов
|   └── quiz_session.py    # Управление состоянием текущего теста
|
├── ui/                    # Компоненты интерфейса (View)
|   ├── main_window.py     # Главное окно
|   ├── quiz_view.py       # Виджет для отображения вопроса и ответов
|   └── result_view.py     # Виджет для отображения результатов
|
├── tests/                 # Директория с тестами
|   └── services/
|       └── test_quiz_session.py
|
├── app_controller.py      # Контроллер (связующее звено)
|
└── main.py                # Точка входа в приложение
```

## 2. Описание Компонентов

### Domain (Модели данных)

Содержит классы, описывающие основные сущности приложения. Это простые структуры данных без логики.

- **`question.py`**: Определяет классы `Answer` и `Question`.
- **`quiz.py`**: Определяет класс `Quiz`, который является контейнером для списка вопросов.

### Services (Бизнес-логика)

Классы, инкапсулирующие бизнес-логику, независимую от пользовательского интерфейса.

- **`quiz_loader.py`**: Отвечает за чтение данных из источников (например, JSON файлов) и преобразование их в объекты домена (`Quiz`, `Question`).
- **`quiz_session.py`**: Управляет состоянием одного сеанса тестирования: отслеживает текущий вопрос, подсчитывает очки, хранит ответы пользователя.

### UI (Представление)

Компоненты PyQt5, отвечающие за отображение данных и взаимодействие с пользователем. Виджеты не содержат бизнес-логики.

- **`main_window.py`**: Главное окно, использующее `QStackedWidget` для переключения между различными экранами (меню, тест, результаты).
- **`quiz_view.py`**: Виджет, отображающий текст вопроса и варианты ответов. Генерирует сигналы при действиях пользователя (например, `next_button_clicked`).
- **`result_view.py`**: Виджет для отображения итогового счета.

### App Controller (Контроллер)

Центральный компонент, который связывает все части приложения.

- **`app_controller.py`**:
    1. Инициализирует UI и сервисы.
    2. Обрабатывает запросы пользователя, полученные от UI (View).
    3. Вызывает соответствующие методы у сервисов для выполнения бизнес-логики.
    4. Обновляет UI актуальными данными из моделей.

### Data

Директория для хранения данных. Использование формата JSON позволяет легко добавлять и редактировать тесты без изменения кода.

## 3. Поток данных (Data Flow)

1.  **Запуск**: `main.py` создает экземпляр `AppController`.
2.  **Инициализация**: `AppController` создает главное окно и загружает список доступных тестов с помощью `QuizLoader`.
3.  **Выбор теста**: Пользователь выбирает тест в UI. UI отправляет сигнал контроллеru.
4.  **Начало теста**: `AppController` получает сигнал, загружает выбранный `Quiz` через `QuizLoader` и создает `QuizSession`.
5.  **Процесс теста**:
    - `AppController` запрашивает текущий вопрос у `QuizSession`.
    - `AppController` передает данные вопроса в `QuizView` для отображения.
    - Пользователь отвечает и нажимает "Далее". `QuizView` отправляет сигнал.
    - `AppController` получает сигнал, передает ответ в `QuizSession` и запраширует следующий вопрос.
6.  **Завершение**: Когда вопросы заканчиваются, `AppController` запрашивает итоговый счет у `QuizSession` и отображает его в `ResultView`.

## 4. Тестирование

Благодаря разделению логики, тесты становятся простыми и понятными. Мы можем тестировать каждый слой архитектуры независимо. Основной инструмент для тестирования — `pytest`, который использует стандартный оператор `assert`.

### Тестирование Сервисов (Services)

Это наиболее важная часть для тестирования, так как здесь сосредоточена вся бизнес-логика. Мы можем "вручную" создать объекты `Quiz` и `Question` и проверить логику сессии, не затрагивая UI или загрузчики файлов.

**Пример для `tests/services/test_quiz_session.py`:**

```python
from domain.question import Question, Answer
from domain.quiz import Quiz
from services.quiz_session import QuizSession

def test_session_correct_answer():
    # 1. Arrange (Подготовка)
    q1 = Question("Какой язык программирования мы используем?", [
        Answer("Java", is_correct=False),
        Answer("Python", is_correct=True),
    ])
    quiz = Quiz("Тест по разработке", questions=[q1])
    session = QuizSession()
    session.start_quiz(quiz)

    # 2. Act (Действие)
    session.submit_answer(answer_index=1) # Пользователь выбирает правильный ответ "Python"
    score = session.calculate_score()

    # 3. Assert (Проверка)
    assert score == 1

def test_session_incorrect_answer():
    # 1. Arrange
    q1 = Question("Какой язык программирования мы используем?", [
        Answer("Java", is_correct=False),
        Answer("Python", is_correct=True),
    ])
    quiz = Quiz("Тест по разработке", questions=[q1])
    session = QuizSession()
    session.start_quiz(quiz)

    # 2. Act
    session.submit_answer(answer_index=0) # Пользователь выбирает неправильный ответ "Java"
    score = session.calculate_score()

    # 3. Assert
    assert score == 0
```

### Тестирование UI и Контроллера

- **Контроллер**: Логику контроллера можно тестировать с помощью "моков" (mocks) — фальшивых объектов, имитирующих поведение UI и сервисов.
- **UI**: Тестирование UI является сложной задачей. Так как наша архитектура выносит всю логику из UI, необходимость в автоматизированных UI-тестах снижается. Основное внимание уделяется ручному тестированию или использованию специализированных фреймворков, таких как `pytest-qt`.