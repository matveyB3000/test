# Реактивные переменные в Python

Реактивное программирование — это парадигма, сфокусированная на работе с потоками данных и распространении изменений. **Реактивная переменная** — это одна из ключевых идей этого подхода.

Проще говоря, это переменная, которая автоматически уведомляет всех «подписчиков» о том, что её значение изменилось.

---

## В чём отличие от обычной переменной?

**Обычная переменная (императивный подход):**

Вы изменили значение, и вам нужно **вручную** вызвать все функции, которые от этого значения зависят.

**Реактивная переменная (реактивный подход):**

Вы «подписываетесь» на изменения переменной один раз. Когда её значение меняется, все подписчики вызываются **автоматически**.

---

## Готовые библиотеки

Создавать свою реализацию каждый раз не нужно. Для сложных сценариев существуют мощные библиотеки, и главная из них — **RxPy**.

---

## Углубляемся в RxPy

**RxPy (ReactiveX for Python)** — это реализация стандарта ReactiveX. Она рассматривает все не как отдельные переменные, а как **потоки событий (streams)**.

### Жизненный цикл потока: `on_next`, `on_error`, `on_completed`

Каждый поток (Observable) следует строгому жизненному циклу, который можно описать формулой: `on_next* (on_error | on_completed)?`

Это означает:
1.  Поток может испустить **ноль или более** значений через `on_next(value)`.
2.  В конце своего жизненного цикла поток может завершиться **только одним из двух способов**:
    - Либо сигналом об ошибке `on_error(error)`.
    - Либо сигналом об успешном завершении `on_completed()`.
3.  После того как поток отправил `on_error` или `on_completed`, он считается **завершенным** и больше не может испускать никаких событий.

Давайте разберем каждый сигнал подробнее:

- **`on_next(value)`**
  Это основной способ передачи данных. Поток может вызывать его сколько угодно раз. Каждый вызов доставляет новое значение всем активным подписчикам.

- **`on_completed()`**
  Это сигнал «до свидания». Он сообщает подписчикам, что поток успешно завершил свою работу и больше не будет присылать значений. Это штатное завершение работы. Многие операторы, которым нужно обработать всю последовательность целиком (например, `count()`, `to_list()`), ждут именно этого сигнала, чтобы испустить свое итоговое значение.

- **`on_error(error)`**
  Это сигнал «тревога!». Он сообщает, что в потоке произошла неисправимая ошибка. Поток немедленно прекращает работу и передает объект ошибки своим подписчикам. После этого поток также считается завершенным.

### Типы Subject

`Subject` — это самый простой способ создать источник, который мультиплексирует значения для нескольких подписчиков. Существует несколько его видов:

- **`Subject`**: Самый базовый. Он просто передает значения всем подписчикам, которые имеются на момент отправки. Если подписаться после отправки значения, вы его не получите. Идеален для «горячих» событий, которые важны только в данный момент (например, «пуля вылетела»).

- **`BehaviorSubject`**: Хранит **последнее** значение. При подписке немедленно отдает его новому подписчику. Идеален для хранения **состояния** (HP, текущий счет, имя пользователя).

- **`ReplaySubject`**: Хранит **буфер** из N последних значений. При подписке отдает новому подписчику весь буфер. Идеален для хранения **истории** событий (последние 5 сообщений в чате, история действий пользователя).

### Создание потоков (Observables)

Помимо `Subject`, есть множество способов создать поток:

- `rx.of(1, 2, 3)`: Создает поток, который выдаст указанные значения и завершится.
- `rx.from_([1, 2, 3])`: Создает поток из итерируемого объекта (список, генератор).
- `rx.interval(1)`: Создает бесконечный поток, выдающий числа (0, 1, 2...) с указанным интервалом в секундах. 
- `rx.create(my_logic)`: Позволяет создать поток со своей собственной логикой отправки значений, ошибок и завершения.

```python
import rx
import time

def create_with_logic(observer, scheduler):
    observer.on_next("Начинаем...")
    time.sleep(1)
    observer.on_next("...завершаем")
    observer.on_completed()

rx.create(create_with_logic).subscribe(print)
```

### Операторы: Суперсила RxPy

Настоящая мощь RxPy — в **операторах**. Это функции, которые позволяют изменять, фильтровать и комбинировать потоки.

- **Фильтрующие**: `filter`, `distinct_until_changed`, `take(5)`, `skip(2)`.
- **Трансформирующие**: `map`, `flat_map` (или `merge_map`). `flat_map` особенно важен, так как он позволяет превращать одно событие в целый новый поток событий.
- **Комбинирующие**: 
    - `merge`: Объединяет несколько потоков в один. События из всех источников идут вперемешку, как придут.
    - `combine_latest`: Объединяет несколько потоков, но выдает значение только тогда, когда **каждый** из потоков прислал хотя бы по одному значению. Затем выдает кортеж из последних значений каждый раз, когда любой из источников присылает новое.
    - `zip`: «Склеивает» значения из нескольких потоков попарно: (1-е из А, 1-е из Б), (2-е из А, 2-е из Б). 

```python
import rx.operators as ops

# Пример с combine_latest: включить кнопку, только если и логин, и пароль валидны
is_login_valid = BehaviorSubject(False)
is_password_valid = BehaviorSubject(False)

can_submit = rx.combine_latest(is_login_valid, is_password_valid).pipe(
    ops.map(lambda values: values[0] and values[1])
)

can_submit.subscribe(lambda can: print(f"Кнопка активна: {can}"))

is_login_valid.on_next(True) # Кнопка активна: False
is_password_valid.on_next(True) # Кнопка активна: True
```

### Управление подписками

В сложном приложении у вас могут быть десятки подписок. Если их не «убивать», когда они больше не нужны (например, при закрытии окна), это приведет к **утечкам памяти**.

Каждый вызов `subscribe()` возвращает объект `disposable`, у которого нужно вызвать метод `dispose()` для отписки.

```python
subscription = source.subscribe(...)
# ...когда больше не нужно...
subscription.dispose()
```

Чтобы управлять множеством подписок, используйте `CompositeDisposable`:

```python
from rx.disposable import CompositeDisposable

disposables = CompositeDisposable()

disposables.add(source1.subscribe(...))
disposables.add(source2.subscribe(...))

# ...когда нужно отписаться от всего сразу...
disposables.dispose()
```

---

## Официальная документация

Для более глубокого изучения всех операторов и возможностей библиотеки, обратитесь к официальной документации.

- **RxPy Documentation**: [https://rxpy.readthedocs.io/](https://rxpy.readthedocs.io/)
